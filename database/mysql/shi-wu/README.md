---
description: MySQL 事务（Transaction）是数据库操作的基本单元，事务的正确使用可以确保数据一致性、完整性和并发安全。
---

# 事务

## 🔷 1. 事务的四大特性（ACID）

事务必须满足 **ACID**（原子性、一致性、隔离性、持久性）：

| **特性**               | **说明**                           |
| -------------------- | -------------------------------- |
| **Atomicity（原子性）**   | 事务是不可分割的操作单元，要么全部执行成功，要么全部回滚。    |
| **Consistency（一致性）** | 事务执行前后，数据要保持一致。例如，转账操作完成后，总金额不变。 |
| **Isolation（隔离性）**   | 并发事务之间互不干扰，数据库提供多个隔离级别保证数据正确性。   |
| **Durability（持久性）**  | 事务一旦提交，即使发生宕机，数据也不会丢失（依赖日志机制）。   |

## 🔷 2. MySQL 事务的使用

### 2.1 事务控制语句

在 MySQL 中，事务的控制语句包括：

```sql
START TRANSACTION; -- 开始事务
SAVEPOINT sp1; -- 创建保存点
ROLLBACK TO sp1; -- 回滚到保存点
COMMIT; -- 提交事务
ROLLBACK; -- 回滚事务
```

### 2.2 事务示例

```sql
START TRANSACTION;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT; -- 提交事务
```

#### 关键点

* START TRANSACTION; 开启事务
* COMMIT; 提交事务，保证数据修改生效
* ROLLBACK; 发生错误时撤销所有修改

## 🔷 3. 事务隔离级别

MySQL InnoDB 引擎提供 **四种事务隔离级别**，隔离性越高，性能可能越低。

| 隔离级别                                      | 脏读    | 不可重复读 | 幻读    | 特点                                      |
| ----------------------------------------- | ----- | ----- | ----- | --------------------------------------- |
| **READ UNCOMMITTED** (读未提交)               | ✅ 可能  | ✅ 可能  | ✅ 可能  | **最低隔离级别**，事务可以读取 **未提交** 的数据，可能导致数据不一致 |
| **READ COMMITTED** (读已提交)                 | ❌ 不可能 | ✅ 可能  | ✅ 可能  | 事务只能读取 **已提交** 的数据，不能保证**重复读**          |
| **REPEATABLE READ** (可重复读) (**MySQL 默认**) | ❌ 不可能 | ❌ 不可能 | ✅ 可能  | **解决不可重复读问题**，但**幻读**可能发生               |
| **SERIALIZABLE** (可串行化)                   | ❌ 不可能 | ❌ 不可能 | ❌ 不可能 | **最高隔离级别**，所有事务串行执行，**性能最低**            |

### 示例

```sql
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ; -- 设置事务级别
```

## 🔷 4. 事务并发问题

在数据库的 **并发事务** 处理中，会遇到以下 **四种并发问题**，不同的事务隔离级别可以避免其中一部分问题。

| 并发问题                            | 描述                                                  | 可能发生的隔离级别                            | 解决方式                    |
| ------------------------------- | --------------------------------------------------- | ------------------------------------ | ----------------------- |
| **脏读 (Dirty Read)**             | 事务 A 读取了事务 B **未提交** 的数据，B 回滚后，A 读取的数据无效            | **READ UNCOMMITTED**                 | **READ COMMITTED 及以上**  |
| **不可重复读 (Non-Repeatable Read)** | 事务 A 在两次查询中，事务 B **提交了修改**，导致 A **前后两次读取的数据不一致**    | **READ COMMITTED**                   | **REPEATABLE READ 及以上** |
| **幻读 (Phantom Read)**           | 事务 A 在查询过程中，事务 B **插入或删除了数据**，导致 A **前后两次查询结果集不一致** | **REPEATABLE READ**                  | **SERIALIZABLE**        |
| **丢失更新 (Lost Update)**          | 事务 A 和事务 B **同时修改** 一条记录，导致 A 的修改被 B **覆盖**，数据丢失    | **READ UNCOMMITTED, READ COMMITTED** | **行锁或 MVCC**            |

### 🔑 关键点

* **READ COMMITTED** 解决了 **脏读** 问题，但**仍然存在不可重复读和幻读**。
* **REPEATABLE READ** 解决了 **脏读和不可重复读**，但 **幻读** 仍可能发生。
* **SERIALIZABLE** **完全避免了** 以上 **所有并发问题**，但 **性能最低**。

## 🔷 5. MySQL 事务日志

在 MySQL InnoDB 存储引擎中，事务的 **持久性 (Durability)** 依赖于 **事务日志**。主要包括 **Redo Log (重做日志)** 和 **Undo Log (回滚日志)**，它们用于保证数据一致性和事务的可靠性。

### 📌 事务日志类型

| 日志类型                | 作用                         | 触发时机      | 主要用途                       |
| ------------------- | -------------------------- | --------- | -------------------------- |
| **Redo Log (重做日志)** | 记录 **已提交事务** 对数据的 **物理变更** | **事务提交后** | **保证事务持久性**，即使崩溃后也能恢复数据    |
| **Undo Log (回滚日志)** | 记录事务的 **逻辑反向操作**，支持事务回滚    | **事务执行时** | **支持事务回滚**，实现 MVCC 以支持一致性读 |

***

### 🔥 **Redo Log（重做日志）**

* **WAL 机制 (Write-Ahead Logging)**：先写日志，再写数据，保证崩溃恢复能力。
* **持久化位置**：
  * **内存中的 Log Buffer**
  * **磁盘上的 Redo Log**
* **刷盘策略**：
  * `innodb_flush_log_at_trx_commit=1` (默认) ：**每次事务提交都会写入磁盘**，保证数据安全。
  * `innodb_flush_log_at_trx_commit=2` ：**每次事务提交写入 OS 缓冲区，但不立即写入磁盘**。
  * `innodb_flush_log_at_trx_commit=0` ：**每秒写入一次磁盘，可能导致事务丢失**。

***

### 🔥 **Undo Log（回滚日志）**

* **回滚操作**：
  * 事务未提交时，可通过 **UNDO** 进行回滚操作。
  * 事务回滚后，数据库状态恢复到事务前的样子。
* **MVCC（多版本并发控制）**：
  * `Undo Log` 让旧版本数据可见，**支持一致性读 (Consistent Read)**。
  * `READ COMMITTED` 和 `REPEATABLE READ` 依赖 `Undo Log` 来提供 **快照读**。

***

### 📌 事务日志应用

* **崩溃恢复**：数据库异常宕机时，通过 `Redo Log` 进行数据恢复。
* **回滚事务**：事务执行失败或 `ROLLBACK` 语句执行时，`Undo Log` 恢复数据状态。
* **MVCC 支持**：多版本控制，提高并发性能，减少锁冲突。

## 🔷 6. MySQL 事务与锁

在 MySQL InnoDB 存储引擎中，锁的机制确保数据一致性和事务隔离。MySQL 提供 **行级锁** 和 **表级锁**，以及共享锁和排他锁来管理并发事务。

### 📌 MySQL 锁的分类

#### 1️⃣ **按锁的粒度分类**

| 锁类型                     | 作用      | 特点               | 适用场景            |
| ----------------------- | ------- | ---------------- | --------------- |
| **行级锁 (Row Locking)**   | 仅锁住操作的行 | 并发能力强，锁粒度小，但开销大  | **大多数 OLTP 场景** |
| **表级锁 (Table Locking)** | 锁住整张表   | 并发能力低，锁冲突严重      | **适用于查询较多的表**   |
| **页级锁 (Page Locking)**  | 以页为单位加锁 | 兼具行锁和表锁优点，但会产生死锁 | **较少使用**        |

***

#### 2️⃣ **按锁的行为分类**

| 锁类型                         | 作用                        | 适用语句                            |
| --------------------------- | ------------------------- | ------------------------------- |
| **共享锁 (S, Shared Lock)**    | 允许多个事务读取，不允许修改            | `SELECT ... LOCK IN SHARE MODE` |
| **排他锁 (X, Exclusive Lock)** | 只允许一个事务访问，不可读不可写          | `SELECT ... FOR UPDATE`         |
| **意向锁 (Intention Lock)**    | 提供加锁提示，加速锁冲突检测            | **系统自动管理**                      |
| **自增长锁 (AUTO-INC Lock)**    | 控制 `AUTO_INCREMENT` 字段并发写 | 适用于 `INSERT` 语句                 |

***

#### 3️⃣ **InnoDB 特有的间隙锁 (Gap Lock)**

* **定义**：锁住一定范围的数据，即使该数据不存在。
* **目的**：防止幻读，保证 `REPEATABLE READ` 级别下的事务一致性。
* **适用场景**：范围查询 (`SELECT * FROM users WHERE age BETWEEN 10 AND 20 FOR UPDATE;`)

***

### 🔥 MySQL 事务与锁的关系

1. **事务的隔离级别决定加锁策略**
   * `READ COMMITTED`：每次查询都重新读取数据，不会产生间隙锁。
   * `REPEATABLE READ`（默认）：使用 **行锁 + 间隙锁**，避免幻读。
   * `SERIALIZABLE`：所有查询都加 **表级共享锁**，并发能力最低。
2. **行锁 vs. 表锁**
   * **InnoDB** 默认使用 **行级锁**，但如果 SQL 语句未使用索引，会自动升级为 **表级锁**。
   * **MyISAM** 只支持 **表级锁**，并发性能较低。

***

### 📌 常见的加锁 SQL 语句

```sql
-- 共享锁 (其他事务可以读取，但不能修改)
SELECT * FROM users WHERE id = 1 LOCK IN SHARE MODE;

-- 排他锁 (其他事务不能读写)
SELECT * FROM users WHERE id = 1 FOR UPDATE;

-- 事务隔离级别导致的锁行为
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
START TRANSACTION;
SELECT * FROM users WHERE age BETWEEN 10 AND 20 FOR UPDATE;
COMMIT;
```

## 🎯 MySQL 事务总结与结论

MySQL 事务是数据库一致性和并发控制的核心概念，理解事务的特性、日志、隔离级别以及锁机制对优化数据库性能至关重要。

### ✅ **事务的关键要点**

1. **ACID 特性**
   * **原子性 (Atomicity)**：事务要么全部执行，要么全部回滚。
   * **一致性 (Consistency)**：事务前后，数据必须保持一致。
   * **隔离性 (Isolation)**：不同事务之间互不干扰。
   * **持久性 (Durability)**：事务提交后数据不会丢失。
2. **MySQL 事务控制**
   * `START TRANSACTION;` 开启事务
   * `COMMIT;` 提交事务
   * `ROLLBACK;` 发生错误时回滚
   * `SAVEPOINT sp1;` 设置保存点
   * `ROLLBACK TO sp1;` 回滚到保存点
3. **事务隔离级别**
   * **READ UNCOMMITTED (读未提交)**：可能产生脏读
   * **READ COMMITTED (读已提交)**：防止脏读，但可能出现不可重复读
   * **REPEATABLE READ (可重复读, 默认)**：防止不可重复读，但可能出现幻读
   * **SERIALIZABLE (可串行化)**：最高级别，所有事务串行执行，性能最低
4. **事务日志**
   * **Redo Log**：保证 **持久性**，事务提交后仍可恢复数据
   * **Undo Log**：支持 **回滚** 和 **MVCC**
5. **事务与锁**
   * **行级锁** (Row Lock)：默认使用，粒度小并发高
   * **表级锁** (Table Lock)：锁住整个表，适用于 MyISAM
   * **间隙锁** (Gap Lock)：防止幻读，默认在 `REPEATABLE READ` 级别生效
   * **意向锁** (Intention Lock)：提示 MySQL 未来加锁的意向，提高并发效率

### 🚀 **优化事务的最佳实践**

* **短事务优先**：减少事务执行时间，降低锁竞争
* **合理使用索引**：防止索引失效导致的表级锁
* **选择合适的隔离级别**：平衡并发与数据一致性
* **使用乐观锁 (CAS) 机制**：避免过多悲观锁带来的性能损耗

### 🎯 **最终结论**

* MySQL 事务提供了强大的 **数据一致性保障**，但不同的隔离级别会影响数据库性能。
* **InnoDB** 存储引擎默认支持 **行级锁** 和 **MVCC**，适用于高并发场景。
* **合理使用索引和事务控制**，可以 **避免死锁，提高数据库吞吐量**。
