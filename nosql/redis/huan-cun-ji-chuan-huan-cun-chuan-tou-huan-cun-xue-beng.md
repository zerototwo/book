---
description: >-
  在高并发系统中，缓存（Redis /
  Memcached）能大幅减少数据库压力，但可能出现缓存击穿、缓存穿透、缓存雪崩等问题，导致数据库负载飙升，甚至引发系统崩溃。
---

# 缓存击穿、缓存穿透、缓存雪崩

## 1. 缓存击穿（Cache Breakdown）

### &#x20;现象

• 某个热点 key（缓存中存在） 突然失效，大量请求直接打到数据库。

• 例如：秒杀商品、热点文章、热门视频，缓存过期瞬间，数据库压力骤增。

### 解决方案

| 方案            | 实现方式                             | 优缺点                   |
| ------------- | -------------------------------- | --------------------- |
| 设置合理的缓存过期时间   | 热点数据的 TTL 随机化，避免同时失效             | ❌ 仍可能瞬时高并发访问数据库       |
| 互斥锁（缓存重建加锁）   | SETNX + EXPIRE 让一个线程更新缓存，其他线程等待  | ✅ 避免大量数据库查询，但可能影响响应时间 |
| 提前预热（定时刷新缓存）  | 提前更新热点数据，确保缓存始终有效                | ✅ 避免过期失效，但增加缓存更新成本    |
| 双层缓存（L1 + L2） | 结合 本地缓存（如 Guava）+ Redis，降低缓存失效影响 | ✅ 进一步减少数据库压力          |

### 代码示例（互斥锁防击穿）

```
String value = redis.get("hot_key");
if (value == null) {
    // 尝试获取互斥锁，防止缓存击穿
    if (redis.setnx("hot_key_lock", "1", 5)) { 
        value = db.query("SELECT data FROM table WHERE id = 1");
        redis.set("hot_key", value, 300); // 重新写入缓存
        redis.del("hot_key_lock"); // 释放锁
    } else {
        Thread.sleep(100); // 让其他线程稍后再查询
        return redis.get("hot_key");
    }
}
return value;
```

适用场景：热点数据（如秒杀商品、热门文章）。

## 2. 缓存穿透（Cache Penetration）

### 现象

• 访问数据库不存在的数据，缓存中也没有，导致请求全部打到数据库。

• 例如：恶意请求、爬虫攻击、错误 ID 查询，会导致数据库压力激增。

### 解决方案

| 方案                  | 实现方式                             | 优缺点              |
| ------------------- | -------------------------------- | ---------------- |
| 布隆过滤器（Bloom Filter） | 拦截非法查询，查询前判断 key 是否存在            | ✅ 高效过滤无效查询，占用空间小 |
| 缓存空值                | 数据库返回 null 时，缓存 null，短时间内不再查询数据库 | ✅ 简单有效，但会占用一定内存  |
| 限流、黑名单              | 识别恶意 IP / 频繁请求，拒绝访问              | ✅ 适用于防止爬虫攻击      |
| 前置校验                | 在接口层增加 ID 规则校验，如 id > 0，防止非法查询   | ✅ 适用于特定业务场景      |

### 代码示例（缓存空值防穿透）

```
String value = redis.get("key_not_exist");
if (value == null) {
    value = db.query("SELECT data FROM table WHERE id = -1"); // 查询不存在的数据
    if (value == null) {
        redis.set("key_not_exist", "", 60); // 缓存空值 1 分钟
    } else {
        redis.set("key_not_exist", value, 300);
    }
}
return value;
```

📌 适用场景：恶意请求防护、数据库查询优化。

## 3. 缓存雪崩（Cache Avalanche）

### 现象

• 大量缓存同时过期，导致所有请求都打到数据库，引发数据库崩溃。

• 例如：热点数据 TTL 设定相同时间，导致大规模缓存失效。

### 解决方案

| 方案            | 实现方式                     | 优缺点                 |
| ------------- | ------------------------ | ------------------- |
| 缓存过期时间随机化     | 随机 TTL 避免同一时间大规模失效       | ✅ 简单易实现，减少瞬时压力      |
| 定时预加载（定时刷新缓存） | 采用后台任务定期更新缓存             | ✅ 可控更新，避免高并发问题      |
| 双层缓存（L1 + L2） | 结合本地缓存 + Redis，减少直接查询数据库 | ✅ 减少数据库压力，提升性能      |
| 请求分级降级        | 采用限流、降级策略，防止数据库雪崩        | ✅ 适用于高并发系统，如秒杀、促销活动 |

### 代码示例（随机 TTL 防雪崩）

```
int randomTTL = 300 + new Random().nextInt(60); // 300~360 秒
redis.set("hot_key", value, randomTTL);
```

📌 适用场景：大规模数据缓存（用户信息、热门商品）。

## 4. 对比总结

| 问题   | 触发条件        | 影响              | 解决方案             |
| ---- | ----------- | --------------- | ---------------- |
| 缓存击穿 | 热点 key 失效   | 单个 key 高并发打爆数据库 | 互斥锁、缓存预热、双层缓存    |
| 缓存穿透 | 查询不存在的数据    | 大量无效查询，打爆数据库    | 布隆过滤器、缓存空值、限流    |
| 缓存雪崩 | 大量 key 同时失效 | 全部请求直击数据库，造成崩溃  | 随机 TTL、双层缓存、限流降级 |

## 5. 选型建议

* 高并发热点数据 → 缓存击穿防护（加锁 / 预热）
* 防止恶意查询 → 缓存穿透防护（布隆过滤器 / 缓存空值）
* 大规模缓存失效 → 缓存雪崩防护（随机过期 / 预加载）

