# MySQL 为什么使用 B+ 树索引？

&#x20;**1️⃣ 为什么不适用二叉搜索树（BST）？**

* 在极端情况下，**二叉搜索树**（BST）可能会退化成**链表**，查询时间复杂度变为 **O(N)**，性能极差。

### **2️⃣ 为什么不使用 AVL 树（平衡二叉树）？**

* **查询复杂度**：AVL 树保持**严格平衡**，查询复杂度为 **O(logN)**，但…
* **维护开销高**：每次插入或删除节点时，可能需要 **旋转** 来保持平衡，影响写入性能。

### **3️⃣ 为什么不使用红黑树（Red-Black Tree）？**

* **优化了旋转**：红黑树不像 AVL 树那样严格平衡，所以**插入、删除的效率较高**。
* **树高较深**：红黑树允许**部分不平衡**，随着数据量增大，**树的高度会变深**，导致查询效率下降。
* **IO 访问次数多**：MySQL 需要从磁盘读取索引，红黑树存储在磁盘上时，**磁盘 IO 过于频繁**，不适合数据库应用。

### **4️⃣ 为什么不使用 B 树（B-Tree）？**

* **B 树每个节点存储数据**：
  * **磁盘 IO 较高**：每次访问非叶子节点都会涉及数据存取，**查询和插入效率较低**。
  * **空间利用率低**：每个节点占用大量存储空间，导致树的高度增大，进而影响查询效率。
* **不适合范围查询**：
  * **叶子节点没有指针链接**，导致**范围查询效率低**。

### **5️⃣ 为什么选择 B+ 树（B+ Tree）？**

✅ **磁盘 IO 更少**：

* 仅**叶子节点**存储数据，非叶子节点仅存 key，提高索引命中率。
* **一个磁盘页存储更多索引**，降低磁盘 IO 次数。

✅ **查询性能稳定**：

* B+ 树的**高度稳定**（通常 3\~5 层），查询时间复杂度接近 **O(logN)**，且 MySQL 采用**主键索引聚簇存储**，减少回表次数。

✅ **范围查询更快**：

* 叶子节点构成**双向链表**，范围查询时可以**顺序遍历**，**不需要回溯**，查询效率更高。

✅ **适合数据库索引结构**：

* **B+ 树天然适用于数据库的** **分页查询、范围查询、排序等操作**，是数据库索引的最佳选择。

***

### **📌 总结（面试重点）**

| **数据结构**                 | **查询复杂度** | **插入/删除复杂度** | **特点**                     | **为什么不适合 MySQL？**             |
| ------------------------ | --------- | ------------ | -------------------------- | ----------------------------- |
| **二叉搜索树 (BST)**          | O(N)      | O(N)         | 退化为链表时性能极差                 | 查询可能退化成 O(N)                  |
| **AVL 树 (平衡二叉树)**        | O(logN)   | O(logN)      | 需要频繁旋转维持平衡，增删改代价大          | 维护成本高，不适合数据库索引                |
| **红黑树 (Red-Black Tree)** | O(logN)   | O(logN)      | 适合频繁插入和删除，树的高度较深           | 查询性能随数据增大下降，磁盘 IO 频繁          |
| **B 树 (B-Tree)**         | O(logN)   | O(logN)      | 非叶子节点存数据，占用磁盘空间大           | IO 开销高，不适合范围查询                |
| **✅ B+ 树 (B+ Tree)**     | O(logN)   | O(logN)      | 叶子节点存数据，非叶子节点只存 key，范围查询更快 | **MySQL 默认索引结构**，查询稳定，磁盘 IO 少 |

🔥 **结论：MySQL 选择 B+ 树，是数据库存储索引的最佳方案！🚀**
