# B+ 树索引 vs. Hash 索引

### 📌 MySQL 中的 B+ 树索引 vs. Hash 索引

***

| **对比项**      | **B+ 树索引（B+ Tree Index）**      | **哈希索引（Hash Index）**             |
| ------------ | ------------------------------ | -------------------------------- |
| **索引结构**     | **B+ 树**（所有叶子节点形成有序链表）         | **哈希表**（key-value 形式）            |
| **查询方式**     | **范围查询**、**排序查询** 高效           | 仅支持 **等值查询**，不支持范围查询             |
| **查询复杂度**    | **O(log n)**，自带排序              | **O(1)**，查找速度极快                  |
| **是否支持范围查询** | ✅ **支持**（BETWEEN、>、<、ORDER BY） | ❌ **不支持**（无法用于范围查询）              |
| **是否支持模糊查询** | ✅ **支持**（LIKE 'abc%'）          | ❌ **不支持**                        |
| **是否支持排序**   | ✅ **支持**                       | ❌ **不支持**                        |
| **回表查询**     | 可能需要回表（非覆盖索引情况）                | 直接存储数据，**不需要回表**                 |
| **索引存储**     | 叶子节点存储数据的**地址**                | 哈希桶存储**完整数据**                    |
| **冲突处理**     | **平衡树结构**，无哈希冲突                | **哈希冲突** 需要处理（链地址法、开放地址法等）       |
| **适用存储引擎**   | ✅ **InnoDB、MyISAM**            | ✅ **Memory 引擎，InnoDB 适配自适应哈希索引** |
| **适用场景**     | **通用索引，适用于大多数场景**              | **高并发等值查询**（如缓存）                 |

***

### **📖 详细解析**

#### **1. B+ 树索引（B+ Tree Index）**

* **B+ 树是一种平衡多叉搜索树**：
  * 所有 **叶子节点** 形成 **有序链表**，支持范围查询。
  * 叶子节点存储的是 **数据的地址**，查找后需要 **回表查询**（除非是覆盖索引）。
  * MySQL **默认索引类型**，适用于 **大多数查询**。
* **适用场景**：
  * **范围查询**（`BETWEEN`、`<`、`>`）。
  * **模糊匹配**（`LIKE 'abc%'`）。
  * **排序查询**（`ORDER BY`）。
  * **通用查询**（适用于各种 SQL）。

***

#### **2. 哈希索引（Hash Index）**

* **哈希索引是基于哈希表（Hash Table）实现的**：
  * **等值查询速度极快**（O(1) 时间复杂度）。
  * **不支持范围查询**，无法进行 `BETWEEN`、`ORDER BY`、`LIKE`（模糊查询）。
  * **哈希冲突问题**，需使用**链地址法**或**开放地址法**解决。
* **适用场景**：
  * **等值查询**（`=`、`IN`）。
  * **高并发的 Key-Value 访问**（如 `Memcached`）。
  * **Memory 引擎的默认索引**。

***

### **📝 结论**

* **B+ 树索引适用于大部分场景，MySQL 默认使用 B+ 树**。
* **哈希索引适用于高并发等值查询（如 Memory 引擎）**。
* **InnoDB 结合两者优点，支持自适应哈希索引**，但主要还是依赖 B+ 树索引。
