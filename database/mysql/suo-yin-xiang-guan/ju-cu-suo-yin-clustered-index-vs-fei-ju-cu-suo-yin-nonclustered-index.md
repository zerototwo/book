# 聚簇索引（Clustered Index） vs 非聚簇索引（Non-clustered Index）

### 聚簇索引（Clustered Index） vs. 非聚簇索引（Non-clustered Index）

***

| **对比项**      | **聚簇索引（Clustered Index）**     | **非聚簇索引（Non-clustered Index）** |
| ------------ | ----------------------------- | ------------------------------ |
| **存储方式**     | 数据和索引存储在一起，索引即数据              | 索引和数据分开存储，索引存的是数据的地址           |
| **数据物理存储顺序** | **数据按照索引顺序存储**                | **索引和数据物理存储无关**                |
| **数据访问方式**   | 直接通过索引找到数据                    | 先通过索引找到数据地址，再进行查询              |
| **查询性能**     | **查询速度快**，因索引和数据在一起           | 需要额外的 **回表查询（回表）**             |
| **更新、插入、删除** | **慢**，因数据物理顺序受影响，可能引起 **页分裂** | **快**，不会影响数据物理顺序               |
| **索引数量限制**   | **一个表只能有一个聚簇索引**              | **一个表可以有多个非聚簇索引**              |
| **适用场景**     | 适合**频繁查询**、**范围查询**           | 适合**多列索引、多条件查询**               |

***

### **📖 详细解析**

#### **1. 聚簇索引（Clustered Index）**

* **特点**：
  * **索引和数据存储在一起**，索引的叶子节点存的就是**实际数据行**。
  * **数据按照索引顺序存储**，相同索引的值物理上存储在一起。
  * 查询时可以**直接找到数据**，不需要回表。
* **限制**：
  * **一个表只能有一个聚簇索引**，因为数据只能按一种方式存储。
  * **插入、删除、更新影响较大**，因为数据位置可能需要调整，导致**页分裂**（Page Split）。
* **适用场景**：
  * **主键默认是聚簇索引**（InnoDB）。
  * **适合范围查询**（例如 `BETWEEN`、`ORDER BY`、`GROUP BY`）。
  * **适合查询热点数据**，因为数据存储顺序有利于磁盘读取优化。

***

#### **2. 非聚簇索引（Non-clustered Index）**

* **特点**：
  * **索引和数据分开存储**，索引的叶子节点存的是**数据的物理地址（rowid）**。
  * **数据物理存储顺序和索引顺序无关**，不会影响数据实际存储位置。
  * **查询时需要回表**，即**先查索引再查数据**（回表查询）。
* **优势**：
  * **可以创建多个非聚簇索引**，加速不同查询需求。
  * **不会影响数据存储顺序**，插入、更新、删除**不会导致数据移动**。
* **适用场景**：
  * **适合多列索引**，比如 `name+age` 组合索引。
  * **适合查询特定字段**，可以使用**覆盖索引（Covering Index）** 避免回表。

***



### **📝 结论**

* **主键索引默认是聚簇索引**（InnoDB）。
* **聚簇索引查询速度快，但更新成本高**。
* **非聚簇索引可以创建多个，但查询时可能需要回表**。
* **合理选择索引类型能显著优化 MySQL 性能**。
